Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизації управління освітленням з можливістю адаптації освітлення під вміст електронних книг

Студент гр. ПЗПІ-21-2	________________________ Кльованик С.С.
(підпис)
Керівник роботи	___________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
_____________________ доц. Лещинська І.О.
(підпис)
___________________ ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 р. 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук         Кафедра програмної інженерії	      
Спеціальність 121 – Інженерія програмного забезпечення	
Курс           3		 Семестр  			            6		     	        
Навчальна дисципліна Архітектура програмного забезпечення	                 

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
                          		     Кльованику Степану Станіславовичу                                           
1. Тема роботи: «Програмна система для автоматизації управління освітленням з можливістю адаптації освітлення під вміст електронних книг»                                                                                                                                   
2. Термін узгодження завдання курсової роботи «25» березня 2024 р.
3. Термін здачі студентом закінченої роботи «21» серпня  2024 р.
4. Вихідні дані до проєкту (роботи):  Програмна система автоматичного керування освітлення, що базується на вмісту сторінок електронних книг. Мобільний додаток – електронна книга, якою користується клієнт у читальних залах, та можливість налаштування освітлення в залі. Система повинна включати в собі: серверну частину, web та mobile застосунки, а також IoT або Smart Device.                                                                                                                        
5. Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз та концептуальне моделювання предметної області, постановка задачі, проектування бази даних, розробка програмної системи, висновки, перелік джерел посилання, додатки.	
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень): ER-модель даних, UML діаграма прецедентів, UML діаграма розгортання, діаграма взаємодії, діаграма пакетів.	


КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проєкту	31.03.2024	
2	Проєктування програмного
проєкту	29.04.2024	
3	Кодування програмного проєкту	28.05.2024	
4	Оформлення пояснювальної
записки	15.08.2024	
5	Захист курсової роботи	21.08.2024	

Дата видачі завдання «25» березня 2024 р.
Керівник	__________________     доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	__________________             Кльованик С.С.
(підпис)
 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 89 с., 25 рис., 2 табл., 2 додатки, 11 джерел.
АВТОМАТИЗАЦІЯ, АДАПТАЦІЯ, БРОНЮВАННЯ, ЕЛЕКТРОННА КНИГА, ЗАЛ, ОСВІТЛЕННЯ, СИСТЕМА.
Об’єктом дослідження є розробка та впровадження інтелектуальної системи управління освітленням, що адаптується до контенту електронних книг.
Метою курсової роботи є розробка програмної системи для автоматизації управління освітленням у читальних залах з можливістю адаптації освітлення під вміст електронних книг. Система дозволить користувачам бронювати читальні зали, налаштовувати освітлення, а персоналу - керувати налаштуваннями та бронюваннями.
Методи розробки базуються на використанні MySQL для управління базою даних, Flask (Python) для розробки серверної частини, React (JavaScript, HTML, CSS, LESS) для створення веб-інтерфейсу, Jetpack Compose (Kotlin) для мобільного додатку та Python для симуляції взаємодії з IoT-пристроєм.
У результаті виконання роботи створено програмну систему, що складається з веб-застосунку для адміністрування, мобільного застосунку для користувачів та симуляції IoT-пристроїв. Система дозволяє автоматизувати управління освітленням, адаптувати його до вмісту електронних книг, бронювати читальні зали.
 
ЗМІСТ



ВСТУП		8
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ	9
1.1	Бізнес-вимоги	9
1.1.1	Бізнес-можливості	9
1.1.2	Бізнес цілі та критерії успіху	10
1.1.3	Потреби клієнта або ринку	10
1.1.4	Бізнес-ризики	11
1.2	Концепція рішення	12
1.2.1	Окреслення концепції	12
1.2.2	Головна функціональність	13
1.2.3	Припущення та залежності	13
1.3	Рамки та обмеження	15
1.3.1	Рамки первинного випуску	15
1.3.2	Рамки наступних випусків	16
1.3.3	Обмеження та винятки	17
1.4	Бізнес-контекст	18
1.4.1	Профілі зацікавлених сторін	18
1.4.2	Пріоритети проєкту	20
1.4.3	Робоче середовище	20
2 ПОСТАНОВКА ЗАДАЧІ	22
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ	24
4 РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ	32
4.1	Архітектура системи	32
4.2	Серверна частина	32
4.2.1	Обирання мови та бібліотек	33
4.2.2	Автентифікація	33
4.2.3	Архітектура	34
4.2.4	REST API	34
4.2.5	Фільтрація, серіалізація з query	37
4.2.6	Автентифікація та безпека	38
4.2.7	Валідації	38
4.2.8	Надбудови над запитами	39
4.2.9	Валідація прав доступу	41
4.3	Розробка веб-застосунку	41
4.3.1	Архітектура	42
4.3.2	Сторінка авторизації	42
4.3.3	Верхня частина всіх сторінок	43
4.3.4	Сторінка бронювання	44
4.3.5	Сторінка менеджменту робітниками	46
4.3.6	Сторінка менеджменту компаніями та закладами	46
4.3.7	Сторінка менеджменту ІоТ-пристроями	47
4.3.8	Сторінка менеджменту літератур	49
4.4	Розробка ІоТ-пристрою	51
4.4.1	Режим роботи із накопичувачем	52
4.4.2	Режим роботи без накопичувача (загальний випадок роботи)	53
4.4.3	Робота з помилками	53
4.4.4	Види конфігурації	54
4.4.5	Визначення нової конфігурації пристрою серверу пристрою	54
4.5	Мобільний додаток	54
4.5.1	Логін та реєстрація	55
4.5.2	Літератури	57
ВИСНОВКИ	62
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	63
ДОДАТОК А	64
А.1 UML діаграма прецедентів	64
А.2 ER-діаграма	65
А.3 Діаграма розгортання	66
ДОДАТОК Б	67
Б.1 Серіалізація	67
Б.2 Фільтрація	76
Б.3 Валідація	81


ВСТУП


У сучасному світі, де електронні книги набувають все більшої популярності, виникає потреба у створенні нових технологій, що зроблять процес читання ще більш комфортним та захоплюючим. Завдяки інноваційним рішенням у сфері розумного освітлення, читачі отримують можливість глибше зануритися у світ літератури, а бізнес-структури, такі як готелі та читальні зали, можуть запропонувати своїм клієнтам унікальний та незабутній досвід.
Існуючі системи управління освітленням, незважаючи на свою функціональність, часто не здатні забезпечити індивідуальний підхід до кожного читача та адаптуватися до специфіки контенту електронних книг. Це обмежує можливості створення оптимальної атмосфери для читання та знижує рівень задоволення користувачів.
Програмна система, що розробляється в рамках даної курсової роботи, спрямована на вирішення цієї проблеми. Вона дозволить автоматизувати управління освітленням у читальних залах, забезпечуючи його адаптацію до вмісту електронних книг, а також надасть користувачам зручний інтерфейс для бронювання місць та персоналу інструменти для ефективного управління системою.
Впровадження такої системи сприятиме підвищенню комфорту читачів, збільшенню їх зацікавленості у читанні, а також дозволить бізнесу залучити нових клієнтів та покращити якість своїх послуг. Це особливо актуально в умовах зростаючої конкуренції та потреби у постійному вдосконаленні сервісу.
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1	Бізнес-вимоги
1.1.1	Бізнес-можливості


На сьогоднішній день існують різні системи управління освітленням. Існують як прості системи, так і з автоматизаціє. Проте більшість з них не мають можливості адаптації освітлення під зміст електронних книг.
	У порівнянні з аналогами, як Mi Bulb та Philips Hue, розроблювана система надає не тільки відповідний до аналогів рівень керування, а й адаптацію освітлення під вміст книги на мобільному застосунку, що є головною унікальною особливістю.
	Існуючі системи як «Marriott's IoT Guestroom Lab» надають клієнтам розумні кімнати в готелях, які насичені смарт-керуванням, в тому числі і освітленням, та має можливості запам’ятовувати власні побажання клієнтів, налаштування в їх акаунтах та відновлювати їх при переході в інші номери. Розроблювана система надає більш вузьке смарт-керування, а саме тільки освітленням, проте, як і з попередніми аналогами, надає можливості адаптації під вміст електронних книг, що також вісутнє у зазначеному аналогу.
Перспективність продукту полягає в якісній інтеграції з існуючими бізнесами готелів, читальних залів та можливості забезпечити безперервний та зручний досвід користувача, враховуючи індивідуальні вподобання та потреби кожного читача, підвищуючи його задоволення від процесу читання та взаємодії з електронними книгами. Перспективи також існують зокрема на ринку Японії, адже в цій країні дуже сильно розповсюджені манґи.
Модель монетизації продукту базується на інтеграції системи з існуючими закладами готелів та читальних залів і стягненні відсотків з бронювання місць у кімнатах. Це дозволяє орієнтуватися на широкий ринок готельного бізнесу, який постійно розвивається і вимагає нових технологій для покращення сервісу. 
Наступні розробки відкривають можливості продажу обладнання не тільки бізнес-лицям, а й звичайним користувачам із підпискою на доступ до літератури у додатку.


1.1.2	Бізнес цілі та критерії успіху


BO-1. Привернути більшу увагу світу до літератури та мистецтва.
BO-2. Забезпечити як новому, так і існуючому готельному бізнесу унікальну особливість для приваблення більшої кількості клієнтів.
BO-3. Надати новій унікальний досвід поціновувачам літератури, забезпечивши нові відчуття від читання.
BO-4. Запропонувати світові нові можливості з використання смарт-пристроїв.
SC-1. Залучення не менше 10 готельних та подібних бізнесів та більше 10.000 споживачів з щонайменше 20% поверненням клієнтів удруге.
SC-2. Випуск готової системи з відлагодженими компонентами та реалізованим функціоналом з можливістю легкого розширення функціоналу для подальшого розвитку проєкту.
SC-3. Якомога менша кількість звертань з приводу ремонту та налагодження несправного ІоТ-обладнання та додатків.


1.1.3	Потреби клієнта або ринку


Розроблюваний продукт повинен враховувати потреби як кінцевих користувачів – читачів, так і проміжних – бізнесів.

Потреби кінцевого користувача:
	Ефективний та зручний дизайн мобільного додатку;
	Варіативність доступних налаштувань освітлення;
	Швидка реакція освітлення на поточні сторінки книги або манґи;
	Оптимальну ціну перебування у відповідних кімнатах з обладненням;
	Безпеку власних даних, налаштувань;
	Запам’ятовування налаштувань та вподобань;
	Потреби клієнтів – бізнесів:
	Оптимальні вимоги та ціна контракту;
	Безпека даних та надійність обладнання;
	Ефективний та зручний веб-застосунок;
	Швидке з’єднання із сервером;


1.1.4	Бізнес-ризики


Система може налічувати наступні ризики:
	Уразливість до хакерських атак на дані користувачів та загальну роботу системи;
	Складність впровадження системи;
	Система не буде відповідати потребам клієнтів та мати невигідні умови контракту;
	Можливі фінансові труднощі;
	Розвиток технологій може призвести до виключення потреби системи (наприклад у випадку збільшення доступності АR та VR технологій);
	Бізнес-посередник, з яким заключено контракт щодо використання технологій зіткнеться з фінансовими труднощами;
	Природні катастрофи, що можуть призвести до пошкодження обладнання в місцях їх використання, що призведе до подальшої потреби надання сервісу ремонту пошкодженого обладнання. Цей ризик враховує особливості Японії, на ринку якого технологія має великий потенціал розповсюдитись;


1.2	Концепція рішення
1.2.1	Окреслення концепції


Концепція полягає в створенні інноваційної системи, яка доповнить спосіб, яким люди сприймають читання електронних книг. Мета продукту - забезпечити користувачам унікальний досвід, що сприяє їхній поглибленій  зануреності у світ літератури та мистецтва завдяки smart-освітленню, та забезпечити готельний бізнес смарт-технологіями та унікальності.
Одна з переваг продукту – впровадження унікальної можливості адаптації освітлення під вміст електронних книг, клієнти отримають можливість насолоджуватися індивідуалізованим та адаптивним освітленням, яке автоматично реагує на контент електронних книг. 
Друга перевага ж полягає у легкій інтегрованості з існуючими готельними та йому подібними бізнесами, забезпечуючи їх смарт-технологіями та унікальною відмінністю від конкурентів. 
В сукупності це покращить якість читання, забезпечить комфорт та задоволення, а також сприятиме приверненню нових клієнтів для партнерів-бізнесів.
Система надаватиме можливості багатостороннього контролю освітленням та  зручного читання книг для користувачів. Крім цього, система надає персоналу відповідних бізнес-партнерів легко та зручно вносити дані щодо клієнтів та заброньованих кімнат.
1.2.2	Головна функціональність


MF-1. Забезпечення зручного та гнучкого керування освітленням кімнати в автономному, автоматичному та гібридних режимах одночасно із зручним читанням манґ та книг у одному додатку;
MF-2. Зручне внесення даних щодо клієнтів та обраними ними кімнатами у систему.
MF-3. Моніторинг стану кімнат та роботи смарт-пристроїв у кімнаті;
MF-4. Забезпечення уповноваженим лицям організації додавати власні налаштування щодо освітлення на основі певних незареєстрованих в глобальному середовищі сторінок книг на манґ для свого бізнесу;
MF-5. Забезпечення зберігання налаштувань користувачами з подальшим відновленням сесії наступного відвідування закладу незалежно від кімнати;


1.2.3	Припущення та залежності


Припускається що:
	Користувачі мобільного додатку володіють базовими навичками користування мобільними девайсами;
	Користувачі ознайомлені з правилами користувацького договору та згодні на них;
	Персонал готелю чи іншого закладу, в якому використовується технологія, ознайомлений з тим, як користуватись веб-додатком;
	Заклад має стабільне інтернет з’єднання та потужний маршрутизатор для підтримки стабільного з’єднання всіх ІоТ-пристроїв та користувачів.
	Користувачі мобільного додатку приєднані до мережі готелю для підтримки зв’язку з локальними у цій мережі ІоТ-пристроями;
	Сервер достатньої потужності, щоб був мінімальний час затримки відгуку;
	Припускається, що при додаванні власниками бізнесів своїх налаштувань на літературу, яка не є у глобальному доступі, мають на це ліцензію та не порушують законодавство країни;
Наявні такі залежності:
	Підтримка мобільного додатку як IOS та і Android систем з якомога більшою підтримкою старих версій систем;
	Доступність мобільного додатку зі слабким залізом, тобто мінімальні системні вимоги;
	Стабільне безперервне з’єднання Інтернет для світла для серверу для підтримки стабільного зв’язку з клієнтами;
	Постійне вдосконалення, оновлення системи задля забезпечення безпеки, сумісності на актуальності технології;
	Необхідність поновлювати договори та розширювати глобальну базу літератури через заключення нових договорів та придбання ліцензій;
	Періодичного сервісу обладнання, що може буте пошкоджено;
	Моніторинг, спостерігання за контентом, що додають окремі бізнеси у систему локальної літератури на порушення законів, авторських прав та ін.; перевірка ліцензій, впровадження відповідних заходів для запобігання наступних ситуацій. Відповідно залежність від кваліфікованого відповідального персоналу;








1.3	Рамки та обмеження
1.3.1	Рамки первинного випуску


Веб-застосунок:
	Бронювання кімнат у системі: видача коду клієнту для підключення до систем у мобільному додатку;
	Перегляд інформації з ІоТ-пристроїв у реальному часі;
	Перегляд статистики щодо всіх кімнат за весь час чи проміжок часу;
	Перегляд інформації за клієнтами;
	Додавання інформації щодо налаштувань освітлення у глобальний доступ та локальний для певного бізнесу;
	Перегляд запитів на додавання контенту та їх верифікація;
Мобільний застосунок:
	Робоча електронна книга з двома режимами для звичайної літератури та манґи;
	Можливість гнучкого налаштування освітлення кімнати;
	Отримування доступу до бібліотеки за кодом;
	Відключення клієнту від системи при впливі часу зі зберіганням сессії;
	ІоТ-пристрої:
	Автоматичне встановлення освітлення;
	Звітування щодо стану на налаштувань на сервер;
	Повідомлення про помилки десинхронізації або інші на сервер та мобільний додаток клієнта;





1.3.2	Рамки наступних випусків


Наступні випуски передбачають такий функціонал:
	Можливість користувачам ділитись з іншими налаштуваннями освітлення;
	Розширення списку мов інтерфейсу;
	Можливість бронювання кімнат та розширювати час знаходження у системі клієнтами через мобільний додаток; введення оплати через додаток;
	Підключення ШІ для аналізу вмісту тих книг, налаштування освітлення яких ще не було задано;
	Додаткова підписка на той матеріал, що за умовами контракту не може бути наданий безкоштовно при бронюванні кімнати та можливість клієнтами включати цей матеріал без підписки при наявності фізичної копії літератури;
	Система лояльності;
	Встановлення комунікації між ІоТ-присторями кімнати для усунення проблем синхронізації режимів освітлення;
	Інтеграція з Google Assistant, Siri та іншими голосовими помічниками для більш зручного контролю освітленням;
	Адаптація режимів освітлення для користувачів з вадами, які стосуються зору (наприклад дальтонізм чи епілепсія);







1.3.3	Обмеження та винятки


Система має наступні обмеження:
	При підключенні до мережі, не пов’язаної з ІоТ-пристроями, користувачі не зможуть відповідно керувати освітленням , так як ІоТ-пристрої підключені до локальної мережі, до якої необхідно бути підключеним користувачам;
	Не весь матеріал (література та манґа) може мати налаштування автоматичного освітлення, або може бути проробленою не повністю чи дуже мало (наприклад, якщо з 256 сторінок тільки 10 відповідають за освітлення);
	Підтримка системи може бути витратною;
	Не весь матеріал можливий для додавання у систему, відповідно користувачі не матимуть доступ до будь-якої літератури;
	Певна література може бути видалена з системи через проблеми з подовженням контракту ліцензії або зміни умов, відповідно користувачі втрачатимуть доступ до відповідних матеріалів;
	Бізнес, що використовує систему, може не мати вільних кімнат з технологією, тому не всі користувачі матимуть змогу в будь-який момент часу забронювати кімнату і одразу нею користуватися;
	Матеріал, що додається бізнесами у локальне сховище, повинен пройти перевірку на ліцензію відповідним персоналом. Перевірки здійснюються людьми, та не всі такі перевірки можуть бути здійснені у веб-застосунку і потребуватимуть додаткових засобів підтвердження. Обмеження полягаю в тому, що не весь новий матеріал одразу потрапляє у доступ та може бути відхиленим;
Винятки:
	Система не передбачає інтеграції з існуючими системами бронювання бізнесів;
	Система попереджає про негативні наслідки на зір для певних лиць з вадами, але не несе відповідальності у разі недотримання вказівкам попередження;
	Система не передбачає якісне Інтернет-з’єднання та не надає маршрутизатори бізнесам;
	Система не підтримує та не розповсюджує піратський та неліцензований контент;
	Компанія не несе відповідальності за проблеми з ліцензійні угоди, яки утворювали окремі компанії;


1.4	Бізнес-контекст
1.4.1	Профілі зацікавлених сторін


Опис профілів зацікавлених сторін наведено у таблиці 4.1.

Таблиця 4.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона	Обмеження	Основні інтереси	Ставлення до програмного продукту	Основна цінність
Користувач мобільного застосунку (кінцевий користувач)	Не знаходить бажану літературу в доступі у додатку або література не підтримує достатню автоматизацію освітлення. Обмежений бюджет для знаходження у кімнаті;	Новий досвід при читанні літератури, нові враження та відчуття	Гарне, якщо застосунок легкий у користуванні, швидкий, зручний, та має бажану літературу у бібліотеці. Скепсис,  якщо застосунок не містить бажаної літератури, або розчарування, якщо користувач збагнув про це вже після придбання доступу до кімнати.	Збереження високого рівня комфорту у  читанні літератури. Безпека власних даних. Приватність.
Користувач веб-застосунку (працівник готелю, працівник компанії)	Недостатня кількість знань для користування системою; відсутність креативного погляду на літературу і відповідне освітлення, якщо це особа, відповідальна за додавання освітлення для нової літератури.	Досвід у роботі з смарт-технологіями. Стимул дізнаватись нову літературу, якщо ще відповідальні за її редагування працівники.	Очікують комфорт у використанні додатку при праці за поставленою роллю у системі.	Безпека власних даних. Гарна заробітна плата. Цікава праця.  
Власник бізнесу (з ним заключено контракт на використання технології у їхньому бізнесі)	Бюджет, який обмежує встановлення обладнання не в усі кімнати. Обмежені здібності обладнання, що сповільнює досвід. Необхідність узгоджувати ліцензії при додаванні своєї літератури	Збільшення доходу, збільшення клієнтів, збільшення репутації, впровадження унікальності для бізнесу	Розглядає продукт як можливість підвищити актуальність свого бізнесу, виділятись серед конкурентів, відчинити двері новим технологіям та співпрацям.	Збільшити актуальність бізнесу, збагачення.
Інвестори 	Ризики втратити гроші	Повернення інвестицій. Ознайомлення зі смарт=технологіями.	Ставлення як до нової технології, яка здатна принести гроші.	Збагачення, соціальна відповідальність
Розробник 	Технічні обмеження, складність розробки, обмежений бюджет, заключення багатої кількості ліцензій.	Успішний розвиток, новаторські рішення, привертання уваги до  читання, розвиток смарт-технологій,	Як до новаторського рішення та до засобу втілити мрії і заробити.	Технічний успіх проєкту, соціальна відповідальність, збагачення.


1.4.2	Пріоритети проєкту


Пріоритети проєкту наведено у таблиці 4.2.

Таблиця 4.2 – Пріоритети проєкту
Показник	Виконання (етапи)	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
Функціонал		Мінімум 60% функціоналу впроваджено	60-70% функцій мають бути розроблені та впроваджені.
Графік робіт	Випуск 1.0 до 21.08.2024	Як мінімум робочі серверна, мобільна, веб та ІоТ частини	Реалізувати якомога більше функціоналу 
Бюджет	Бюджет не передбачено	Бюджет не передбачено	Бюджет не передбачено
Команда	Кльованик С.С.	Одна людина	Тільки одна людина
Якість		Повинна бути працездатна система	У першому випуску якомога більше тестів; наступні випуски потребуватимуть якомога більше тестів.


1.4.3	Робоче середовище


Відповідно до частин, що необхідно розробити:
	DBMS: MySQL;
	Back-end (сервер): Flask (Python);
	Front-end (веб-застосунок): React (JavaScript, HTML, CSS);
	Mobile: Kotlin;
	IoT: симуляція на Python;
Кінцеві користувачі, тобто клієнти закладів, де встановлено обладнання, не далеко поширені, розташовані поруч із маршрутизатором, до якого підключені ІоТ-пристрої в кімнатах. Персонал бізнесу може бути як в самому закладі (відповідальний за реєстрацію клієнтів, бронювання номерів), так і поза ним (відповідальні за оновлення інформації про літературу). Персонал самого проєкту, а не окремих бізнесів, може працювати як в офісі, так і поза офісом.
Система повинна бути доступною завжди, швидкою та надійною. Система повинна мати засоби резервного збереження даних у разі критичних помилок. Система повинна забезпечувати безпеку власних даних користувачів та їхню конфіденціальність.
Обмін даними між сервером і мобільними та веб застосунками безпосереднє. Дані до ІоТ-пристроїв надходять через мобільний додаток, а з ІоТ-пристроїв – до мобільних застосунків та серверу. Більшість даних генерується у веб-застосунку. Дані клієнтів оновлюються та змінюються через веб та мобільні застосунки.
2 ПОСТАНОВКА ЗАДАЧІ


Згідно з проведеним аналізом предметної області та визначеними бізнес-цілями, основним завданням курсової роботи є розробка комплексної програмної системи для автоматизації управління освітленням з можливістю адаптації до вмісту електронних книг. Система повинна забезпечити користувачам унікальний та комфортний досвід читання, а також надати бізнесам інструменти для підвищення ефективності та залучення нових клієнтів.
Для досягнення поставленої мети необхідно реалізувати наступний функціонал (див А.1):
а)	Для користувачів мобільного застосунку:
‒	Створення облікового запису;
‒	Авторизація та управління обліковим записом;
‒	Перегляд списку всіх літератур всіх компаній;
‒	Перегляд списку літератур, можливих для читання згідно поточному бронюванню користувача;
‒	Фільтрація та пошук необхідної літератури з багатьох;
‒	Читання літератур у додатку;
б)	Для персоналу веб-застосунку:
‒	Авторизація та управління обліковими записами персоналу.
‒	Управління бронюванням: підтвердження, скасування, перегляд історії
‒	Управління IoT-пристроями: додавання, налаштування, видалення;
‒	Управління персоналом: видалення, додавання, редагування прав доступу;
‒	Управління літературами: додавання, видалення, редагування, додавання файлів відносно літератур, редагування конфігурації кольорів для сторінок;

в)	Для IoT-пристроїв:
‒	Утворення зв’язку з читачами: можливість отримувати конфігурації освітлення під час читання літератури відносно поточної сторінки з мобільного пристрою;
‒	Підтримка декількох режимів освітлення: стале та переливання між кольорами;
‒	Реагування на помилки під час роботи і повідомлення про них користувачам чи персоналу;
‒	Утворення зв’язку із сервером: реєстрація пристрою на сервері; 
Програмна система повинна забезпечувати високий рівень безпеки та захисту даних користувачів, а також бути масштабованою та гнучкою для подальшого розвитку та впровадження нових функцій. Важливим аспектом є також зручність та інтуїтивна зрозумілість інтерфейсів користувача як для мобільного, так і для веб-застосунку.

3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ


Для проектування структури бази даних програмної системи було розроблено ER діаграму (див. А.2).
База даних містить наступні сутності та зав’язки:
Сутність: Користувач (User)
Атрибути:
‒	email (PK)
‒	nickname
‒	real_name
‒	real_surname
‒	phone_number
‒	password_hash
‒	country_id (FK)
Зв'язки:
а)	З країною (Country):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожен користувач належить до однієї країни.
б)	З працівником (Employee):
‒	Тип зв'язку: Один до одного (опціонально)
‒	Опис: Користувач може бути працівником, але не обов'язково.
в)	З бронюваннями (Booking):
‒	Тип зв'язку: Багато до багатьох (через таблицю user_booking)
‒	Опис: Користувач може мати багато бронювань, і кожне бронювання може належати багатьом користувачам.
Сутність: Працівник (Employee)
Атрибути:
‒	user_email (PK, FK)
‒	establishment_id (FK)
‒	head_manager
‒	booking_manager
‒	literature_manager
‒	iot_manager
Зв'язки:
а)	З користувачем (User):
‒	Тип зв'язку: Один до одного
‒	Опис: Кожен працівник є користувачем системи.
б)	Із закладом (Establishment):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожен працівник працює в одному закладі.
в)	З зареєстрованими бронюваннями (Booking):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Працівник може зареєструвати багато бронювань.
г)	З відредагованими літературними творами (Literature):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Працівник може редагувати багато літературних творів
Сутність: Компанія (Company)
Атрибути:
‒	id (PK)
‒	name
‒	global_access_company
Зв'язки:
а)	З закладами (Establishment):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Компанія може мати багато закладів.
б)	З літературними творами (Literature):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Компанія може володіти багатьма літературними творами
Сутність: Заклад (Establishment)
Атрибути:
‒	id (PK)
‒	address
‒	company_id (FK)
‒	country_id (FK)
Зв'язки:
а)	З компанією (Company):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожен заклад належить до однієї компанії
б)	З країною (Country):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожен заклад знаходиться в одній країні
в)	З кімнатами (Room):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Заклад може мати багато кімнат
г)	З працівниками (Employee):
‒	Тип зв'язку: Один до багатьох
‒	Опис: У закладі може працювати багато працівників
Сутність: Країна (Country)
Атрибути:
‒	id (PK)
‒	name
‒	charcode
‒	code
Зв'язки:
а)	З користувачами (User):
‒	Тип зв'язку: Один до багатьох
‒	Опис: У країні може бути багато користувачів
б)	З закладами (Establishment):
‒	Тип зв'язку: Один до багатьох
‒	Опис: У країні може бути багато закладів
Сутність: Кімната (Room)
Атрибути:
‒	id (PK)
‒	label
‒	establishment_id (FK)
Зв'язки:
а)	З закладом (Establishment):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожна кімната належить до одного закладу
б)	З пристроями освітлення (LightDevice):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Кімната може мати багато пристроїв освітлення
в)	З бронюваннями (Booking):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Кімнату можна бронювати багато разів
Сутність: Тип освітлення (LightType)
Атрибути:
‒	name (PK)
Зв'язки:
а)	З пристроями освітлення (LightDevice):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Тип освітлення може бути використаний у багатьох пристроях
б)	З конфігураціями сторінок літературних творів (LiteraturePageConfig):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Тип освітлення може бути вказаний у багатьох конфігураціях сторінок
Сутність: Пристрій освітлення (LightDevice)
Атрибути:
‒	id (PK)
‒	port
‒	host
‒	light_type_name (FK)
‒	room_id (FK)
‒	details
Зв'язки:
а)	З типом освітлення (LightType):
‒	Тип зв'язку: Багато до одного (опціонально)
‒	Опис: Кожен пристрій освітлення може мати один тип освітлення або не мати його взагалі
б)	З кімнатою (Room):
‒	Тип зв'язку: Багато до одного (опціонально)
‒	Опис: Кожен пристрій освітлення може бути встановлений в одній кімнаті або не бути встановленим взагалі
Сутність: Автор (Author)
Атрибути:
‒	id (PK)
‒	pseudonym
‒	name (опціонально)
‒	surname (опціонально)
Зв'язки:
в)	З літературними творами (Literature):
‒	Тип зв'язку: Багато до багатьох (через таблицю literature_author)
‒	Опис: Автор може написати багато творів, і кожен твір може мати багатьох авторів
Сутність: Жанр (Genre)
Атрибути:
‒	name (PK)
Зв'язки:
а)	З літературними творами (Literature):
‒	Тип зв'язку: Багато до багатьох (через таблицю literature_genre)
‒	Опис: Жанр може бути присвоєний багатьом творам, і кожен твір може мати багато жанрів
Сутність: Тип літератури (LiteratureType)
Атрибути:
‒	name (PK)
Зв'язки:
а)	З літературними творами (Literature):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Тип літератури може бути присвоєний багатьом творам
Сутність: Літературний твір (Literature)
Атрибути:
‒	id (PK)
‒	name
‒	description
‒	pages (опціонально)
‒	min_age (опціонально)
‒	pdf_PATH (опціонально)
‒	thumbnail_PATH (опціонально)
‒	editor_email (FK)
‒	company_id (FK)
‒	type_name (FK)
Зв'язки:
а)	З типом літератури (LiteratureType):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожен літературний твір має один тип (книга, манґа тощо).
б)	З авторами (Author):
‒	Тип зв'язку: Багато до багатьох (через таблицю literature_author)
‒	Опис: Твір може мати декілька авторів, і автор може написати декілька творів
а)	З жанрами (Genre):
‒	Тип зв'язку: Багато до багатьох (через таблицю literature_genre)
‒	Опис: Твір може належати до декількох жанрів, і жанр може бути присвоєний багатьом творам.
б)	З конфігураціями сторінок (LiteraturePageConfig):
‒	Тип зв'язку: Один до багатьох
‒	Опис: Літературний твір може мати багато конфігурацій сторінок для налаштування освітлення
в)	З редактором (Employee):
‒	Тип зв'язку: Багато до одного (опціонально)
‒	Опис: Літературний твір може бути відредагований працівником (якщо це передбачено системою), або не мати редактора
г)	З компанією (Company):
‒	Тип зв'язку: Багато до одного (опціонально)
‒	Опис: Літературний твір може належати певній компанії (якщо він не є загальнодоступним) або не належати жодній
Сутність: Бронювання (Booking)
Атрибути:
	id (PK)
	registration_time
	expiration_time
	registrator_email (FK)
	room_id (FK)
Зв'язки:
а)	З реєстратором (Employee):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожне бронювання реєструється одним працівником
б)	З кімнатою (Room):
‒	Тип зв'язку: Багато до одного
‒	Опис: Бронювання стосується однієї конкретної кімнати
в)	З користувачами (User):
‒	Тип зв'язку: Багато до багатьох (через таблицю user_booking)
‒	Опис: Одне бронювання може бути створене для декількох користувачів, і користувач може мати декілька бронювань
Сутність: Користувач-бронювання (UserBooking)
Атрибути:
	user_email (PK, FK)
	booking_id (PK, FK)
Зв'язки:
Використовується виключно для реалізації зв'язку багато-до-багатьох між User та Booking
Сутність: Конфігурація сторінки літературного твору (LiteraturePageConfig)
Атрибути:
	id (PK)
	literature_id (FK)
	page_number
	light_type_name (FK)
	configuration
Зв'язки:
а)	З літературним твором (Literature):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожна конфігурація стосується конкретної сторінки конкретного твору
б)	З типом освітлення (LightType):
‒	Тип зв'язку: Багато до одного
‒	Опис: Кожна конфігурація визначає налаштування для певного типу освітлення

4 РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ
4.1	Архітектура системи

Для розуміння взаємодії всіх рівнів системи було розроблено діаграму розгортання (див. А.3). за схемою можна чітко побачити, що планується одна основна серверна частина, та другорядна, на стороні ІоТ-пристрою. Але вона міститься з одного обробника запиту, тому як повноцінний сервер не вважатиметься.


4.2	Серверна частина


Серверна частина відповідає за надання клієнтів необхідними даними. Існуючі користувачі  не просто поділяються на клієнтів закладу та персонал, але й розрізняються за правами доступу до різних шарів даних. Так, користувачеві без автентифікації доступний тільки вхід та реєстрація. В свою чергу без зареєстрованого та активного бронювання номеру у закладі користувач може лише переглядати ті літератури та їх описи, які доступні у системі, а не читати. А коли може читати, то тільки літератури глобального доступу та компанії, в якій поточне бронювання активне.
У персоналу ще більше розгалуження:
	Менеджер з бронювання;
	Менеджер з літератур;
	Менеджер робітників;
	Менеджер IoT-пристроїв;
Кожен у відповідності до ролі займається тим, яка роль надана, і не більше, в межах своєї компанії.
На додачу, існують глобальні компанії, або компанії-засновники. Розгалуження прав таке ж саме, проте доступ вже надається не в межах компанії, а всіх компаній. 
Висновком з цього можна зробити, що на сервері потребується жорстока валідація користувачів, чітке визначення меж, прав, що необхідні для запитів.


4.2.1	Обирання мови та бібліотек


Для розробки серверної частини було обрано мову програмування Python із використанням бібліотеки Flask[1]. Середовищем розробки став PyCharm[2].
Наступні основні залежності було використано:
	Flask-login[3] – для автентифікації;
	Marshmallow[4] – для шару валідації через серіалізацію;
	SQLAlchemy[5] – для взаємодії із базою даних (MySQL[6]) за принципом 
code-first: моделі пишуться на Python і далі створюються у базі даних;
	Pillow: для роботи із зображеннями.


4.2.2	Автентифікація


Flask-login використовувався для автентифікації виду «Basic auth»[7]. Логін та пароль кодуються та передаються на сервер, повертається сесія, вміст якої у подальших запитах свідчить про те, який користувач виконує запит.




4.2.3	Архітектура


Архітектура серверної частини – 3-рівнева – відповідно включає в себе:
	Презентаційний рівень – це обробники запитів. В контексті програмної реалізації це один «.py» файл на кожну модель бази даних. Складається завжди із запитів, які взаємодіють із базою даних за принципом CRUD (Create Read Update Delete)[8], та додатковими обробниками запитів для автентифікації, окремими фільтраціями даних, що було виділено у окремі запити через зручність або з причин різного доступу до різної кількості даних одного типу через різні ролі в системі;
	Бізнес-логіка – це велика кількість валідації: вхідних даних, автентифікації, прав доступу, що відрізняються між робітниками тощо. Цей шар також відповідає за фільтрацію та багаторівневу серіалізацію даних через Query у запитах, і за надбудови над рівнем презентації для централізації коду і спрощення реалізації презентаційного рівня;
	Рівень доступу до бази даних – відповідний рівень забезпечує моделі взаємодії із даними з БД, сесії для подальшої роботи із даними, та впроваджує можливість зміни СУБД без суттєвих змін на роботу інших частин.


4.2.4	REST API


Серверна частина відповідає вимогам REST[9] специфікації. Нижче наведено основні посилання для взаємодії із даними через сервер. Наведено лише для деяких моделей, проте визначено для всіх моделей. Більшість – однотипні, та мають лише 5 відповідних до CRUD обробників посилань.
Основне посилання складається з «host:port/api/v2/»
Таблиця 4.2 - Специфікація REST API
Сутність	Метод	Посилання	Результат	Обмеження
Літератури	POST	/literatures/	Створення нової літератури	Наявність автентифікації та прав на редагування літератур. Розповсюджується тільки на літератури, що належать компанії того, хто запитує, або на усі літератури, якщо редагування запитує користувач компанії глобального рівня.
	GET	/literatures/	Отримання усіх літератур	Наявність автентифікації
	GET	/literatures/[id]	Отримання певної літератури	Наявність автентифікації
	PUT	/literatures/[id]	Редагування літератури	Як і для створення
	DELETE	/literatures/[id]	Видалення літератури	Як і для створення
	GET	/literatures/available	Усі літератури, які можна прочитати користувачеві	Автентифікація та наявність принаймні одного активного сеансу бронювання, або бути робітником 
	GET	/literatures/editable	Усі літератури, які може відредагувати користувач	Автентифікація, бути робітником та мати права на редагування літератур
	GET	/literatures/[id]/thumbnails	Повертає обкладинку для літератури	Автентифікація
	GET	/literatures/[id]/pdf	Повертає .pdf файл	Автентифікація, наявність активної сесії бронювання або бути робітником. Можна отримати тільки своєї компанії. Або всіх, якщо права редагування у робітника глобального рівня.
ІоТ-пристрої	PUT/POST/GET/DELETE	/light_devices/
/light_devices/[id]	Відповідно до CRUD	Автентифікація, наявність прав на роботу з IoT-пристроями
	POST	iot_registration_service/[establishment_id]
	Утворює міст для подальшого приєднання IoT-пристроїв до системи та повертає унікальний ключ	
	GET		Отримує унікальний ключ, якщо міст було відкрито. На відміну вметоду вище, не утворює новий ключ при кожному запиті	
	DELETE		Закриває міст, ключ стає недійсним	
	POST	iot_registration_service/<establishment_id>/room/<room_id>
	Визначає кімнату за ключем. Без визначення IoT-пристрій буде стикатись із помилкою реєстрації, так як кімнату не було визначено	
	POST	/iot_registration_service/register/<code>/<host>
<code> - зазначений вище код доступу
	Реєструє пристрій у системі. Пристрій передає свій хост, отримує порт, на якому він може відкривати сервер. Пристрій додається у базу даних. При успішній реєстрації також отримує новий ключ доступу для реєстрації подальших пристроїв	Немає обмежень, але потребується ключ доступу
	GET	/light_devices/first_accessible
	Отримання користувачем із активною сесією бронювання доступних пристроїв. Необхідне спрощення для мобільного застосунку	Автентифікація та наявність сесії бронювання


4.2.5	Фільтрація, серіалізація з query


Сервер підтримує багаторівневу серіалізацію даних та базову фільтрацію через query-параметри у запиті (див. Б.1 та Б.2).
Наприклад «/api/v2/literatures/?I=literature,author.pseudonym,literature_page_config&filter=min_age>=14&join=literature_page_config&filter=literature_page_config.light_type_name~sun» повертає всі літератури і зазначеним віком не менше 14 та з наявністю у конфігураціях для освітлення конфігурація для освітлення типу «Sun» (і містити буде тільки ці конфігурації)
Такі параметри як «max» та «limit» обмежують кількість записів на повертання та зсув. Таке рішення швидше за повернення всіх даних та їх подальшу фільтрацію у застосунку адже це початково відфільтровані дані, отримані з відповідного запиту до бази даних.


4.2.6	Автентифікація та безпека


Автентифікація виконується за запитом «/login» та потребує кодування логіну та паролю для «basic auth» методу у форматі base64. Подальше надсилання логіну та паролю вже не потребується, сесія дійсна до втрати ключа сесії чи місяць.
Безпека паролів користувачів здійснюється їх збереженням у зашифрованому вигляді в базі даних завдяки бібліотеці «Flask-bcrypt». Шифрування основане на початковому значення «secret-key» застосунку. При його зміні паролі стають недійсними.
При вході переданий пароль шифрується та порівнюється з тим, що у базі даних. Це одностороннє шифрування.


4.2.7	Валідації


На сервері здійснюється найбільша кількість валідації даних. Цього достатньо, щоб клієнтські застосункам залишалось тільки реагувати на відповіді з сервера та помилки. Валідацію реалізовано на основі шаблону «handler»[10]. Вони будуються послідовно, та виконують операції над даними, нічого не повертають, якщо все добре, або провокують помилку у разі помилки валідації, і надсилають дані на наступну функцію у ланцюгу, мутуючи дані за необхідністю.

Програмна реалізація серверу займається наступними перевірками (див Б.3):
	перевіряє, чи запит містить коректний json;
	конвертує сирі json-дані у відповідні типи для моделі бази даних;
	адаптує типи даних до типів, визначених у моделі бази даних та повертає помилку, якщо дані неправильного формату;
	перевіряє, чи в запиті немає зайвих полів, які не відповідають колонкам моделі;
	перевіряє, чи в запиті присутні всі обов'язкові поля моделі;
	перевіряє, чи в запиті присутні поля первинного ключа;
	перевіряє, чи об'єкт з заданим первинним ключем існує в базі даних;
	перевіряє, чи об'єкт з заданим первинним ключем не існує в базі даних;
	перевіряє, чи об'єкти, на які посилаються зовнішні ключі, існують в базі даних;
	перевіряє дані за допомогою схеми marshmallow, прив'язаної до моделі бази даних;
	перевіряє коректність даних для створення нового об'єкта в базі даних.
	перевіряє коректність даних для читання або видалення об'єкта з бази даних;
	перевіряє коректність даних для оновлення об'єкта в базі даних.
	перевіряє наявність та тип авторизації в запиті;
	перевіряє коректність формату електронної пошти;
	перевіряє, чи користувач з вказаною електронною поштою існує;
	перевіряє відповідність введеного пароля паролю з бази даних.


4.2.8	Надбудови над запитами


Бібліотека Flask не дозволяє швидко впроваджувати однотипні запити та перевірки для даних, які цього потребують, через це виникає дублювання коду: один запит створюється з декоратору та тіла, в кожному тілі робиться валідація та конвертація даних. Коли моделей більше 10, кількість таких однотипних запитів зростає.
Протягом реалізацію програмного продукту було розроблено різні рівні надбудов:
-	«Weak body builder» - відповідає за будування тіла на основі встановлення багатьох характеристик під час будови: сесії, типу запиту, моделі, з якою працює запит, модифікаторів для читання багатьох записів для query, додаткових callback функцій після основної валідації та самого валідатору. Таку назву було обрано через нечітку визначеність у необхідних даних для вдалого будування тіла запиту. 
-	«Body factory» - надбудова над попереднім будівником тіла запиту. Фабрика використовує будівник та пропонує відповідні 5 видів тіл для CRUD-операцій, і є більш безпечною, адже правильно визначає необхідні для будування дані для будівника;
-	«Routes builder». Попередні рішення все ще зобов’язують власноруч писати по 5 запитів мінімум для кожної моделі. Наприклад ,при додаванні нового декоратору для одного з видів запитів необхідно буде відредагувати кожен файл окремо. Будівник шляхів пропонує надбудову над фабрикою тіла, валідаторами та Flask разом, впроваджуючи дуже зручний і красивий для читання і розуміння синтаксис створення шляхів на сервер. Ця надбудова зменшує кількість коду, необхідного для побудови презентаціяного рівню в рази, а також централізує, уніфікує багато шарів обробки запиту, що забезпечує легке відстеження помилок.






4.2.9	Валідація прав доступу


Відповідно до ролей, що зазначені у робітників в їх моделях, необхідне впровадження валідації для певних запитів, які мають бути доступними лише тим чи іншим категоріям прав доступу. Для цього було розроблено декоратор, який перевіряє права у робітників. На додачу, так як у звичайних користувачів немає розрізнення за правами доступу, декоратор повертає помилку, якщо користувач не робітник, що робить запит з цим декоратором автоматично доступним лише робітникам.


4.3	Розробка веб-застосунку


Для розробки було обрано React. 
Для візуалізації використаних пакетів було розроблено діаграму пакетів 
(див. рис. 4.1)

 
Рисунок 4.2. Діаграма пакетів веб-застосунку

Веб-застосунок надає робітникам, що залучені у проекті, відповідні до їх ролей у системи доступи до даних.
Так як вся валідація даних виконується сервером, клієнтським застосункам залишається лише виконувати запити, та реагувати на відповіді з серверу.


4.3.1	Архітектура


Архітектура веб-застосунку проста та є Feature-Sliced[11], тобто розділена на основні шари, відповідальні за одну галузь функціоналу застосунку.
Налічуються наступні шари:
-	Components – невеликі компоненти, проміжні для побудови;
-	Models – моделі, що спрощують використання API;
-	Routes – шляхи. Містить основний функціонал, кожен файл відповідає за функціонал певної сторінки;
-	Styles – стилі для відповідних шляхів.
Також основний файл – «App.js» – який визначає в собі посилання на сервер, найбільш головні компоненти, які доступні з усіх сторінок, та визначає навігацію на компоненти, визначені у Routes.


4.3.2	Сторінка авторизації


Застосунок не передбачає реєстрацію робітниками: їх реєструють менеджери, відповідальні за співробітників.
Форма входу дуже проста та показана на рисунку 4.2.
На рисунку 4.3 можна побачити те, як виглядають повідомлення про помилки.

 
Рисунок 4.2. Форма авторизації

 
Рисунок 4.3. Повідомлення про помилку невірного паролю


4.3.3	Верхня частина всіх сторінок


У всіх сторінок при вдалому вході наявний header (рис. 4.4). На ньому можна побачити, хто поточний користувач, обрати компанію, якщо це робітник глобального рівня доступу, та перейти на сторінки контролю за різними елементами бази даних.
На рисунку 4.4 показано випадок, якщо я адміністратор глобального рівня.
На рисунку 4.5 показано випадок для менеджера з персоналу та бронювання.
Як можна побачити, у другого менше доступних опцій, адже у нього менше прав доступу (див. рис. 4.6).

 
Рисунок 4.4. Header для головного адміністратору.

 
Рисунок 4.5. Header для менеджеру з бронювання та персоналу локальної компанії.

 
Рисунок 4.6. Права доступу «lhm@example.com»


4.3.4	Сторінка бронювання


На сторінці бронювання можна подивитись поточні бронювання на певні будівлі певних кімнат (див. рис. 4.7.). Бронювання підтримують декількох користувачів. Валідація дат виконується на стороні клієнту. Мінімальний час бронювання становить 2 години, а наступне на ту ж саму кімнату можливо зробити через годину після закінчення минулого (рис. 4.8). 

 
Рисунок. 4.7. Сторінка бронювання.

 
Рисунок 4.8. Найближчий доступний час на те й саме число закінчення тільки через годину та більше після закінчення минулого бронювання.






4.3.5	Сторінка менеджменту робітниками


На цій сторінці можна маніпулювати правами доступу робітників, додавати робітників та видаляти робітників (див. рис. 4.9).


 
Рисунок 4.9. Сторінка менеджменту робітниками.


4.3.6	Сторінка менеджменту компаніями та закладами


Ця сторінка доступна тільки при наявності комбінації прав доступу до менеджменту персоналом та знаходження у глобальній компанії.
Сторінка дозволяє керувати зазначеними сутностями (див. рис. 4.10).

 
Рисунок 4.10. Сторінка менеджменту компаніями та їх закладами.


4.3.7	Сторінка менеджменту ІоТ-пристроями


Сторінка дозволяє персоналу з відповідним правом доступу керувати пристроями в системі (див. рис. 4.11). 
На сторінці можна відкрити міст для реєстрації пристроїв, змінити кімнату, та завантажити файл з кодом доступу, який у подальшому використовується з ІоТ-пристроями (див. рис. 4.12 та 4.13).

 
Рисунок 4.11. Сторінка керування ІоТ-пристроями.

 
Рисунок 4.12. Приклад відкритого мосту для з’єднання пристроїв.

 
Рисунок 4.13. Файл з кодом доступу.




4.3.8	Сторінка менеджменту літератур


На сторінці можна переглянути доступні для редагування літератури 
(див. рис. 4.14).
Вікно редагування показано на рисунку 4.15.
В самому вікні нижче після редагування літератури можна редагувати і конфігурації для пристроїв (див. рис. 4.16).

 
Рисунок 4.14. Вікно менеджменту літературами.

 
Рисунок 4.15. Вікно редагування літератури.

 
Рисунок 4.16. Вікно редагування конфігурацій сторінок.


4.4	Розробка ІоТ-пристрою


Пристрій інтернет-речей було симульовано мовою Python, з можливість використання у подальшому з MicroPython завдяки використанню лише вбудованих бібліотек у мову. Замість реального компоненту освітлення використовується tkinter для відображення кольору (див. рис. 4.17)
Пристрій має два режими, які визначаються, чи є в пристрої флеш-накопичувач, чи ні.


 
Рисунок 4.17. Симуляція відображення кольору з діоду пристрою


4.4.1	Режим роботи із накопичувачем


Попередньо в описі частин веб-застосунку (див. п. 4.3.7) було зазначено можливість завантажити код доступу у вигляді файлу. Цей файл розташовується у корені флеш-накопичувача, та підключається до пристрою. Пристрій включиться у режимі налагодження та намагатиметься знайти файл, звернутись до основного сервера та зареєструвати пристрій за тим кодом доступу, що у файлі.
При вдалій операції пристрій повідомить про це зміною кольору протягом декількох секунд з білого на зелений в швидкому темпі та вимкнеться. 
При цьому він змінить код доступу у файлі на новий з серверу. Зміна коду доступу зроблена з поглядів безпеки, бо шлях доступний будь-якому користувачеві. Така система дозволяє без проблем додати пристрої.
Якщо з пристроями в кімнаті закінчено, через веб-застосунок можна змінити кімнату без необхідності зміни закладу та нового утворення ключу доступу.


4.4.2	Режим роботи без накопичувача (загальний випадок роботи)


У разі відсутності накопичувача, пристрій працює в своєму звичайному режимі. Якщо конфігурація не містить порту, буде відповідно утворено помилку і це супроводжуватиметься сигналом (див. п. 4.4.3).
При вдалому запуску сервера пристрій протягом декількох секунд змінюватиме колір з зеленого на чорний, а потім перейде в режим очікування на запити на зміну кольору. Якщо попередньо було встановлено якісь налаштування кольорів перед тим як пристрій вимкнувся, він завантажить останнє налаштування.


4.4.3	Робота з помилками 


Клас «MessageCode» (див. В.1 рядок 21 - 29) відповідає за кольорові співвідношення з деякими можливими помилками при роботі девайсу.
Після помилки девайс буде вимкнено.
Якщо виникає помилка, пов’язана із реєстрацією пристрою на сервері, додатково буде спроба утворити в корені флеш-накопичувача файл із відповіддю сервера.






4.4.4	Види конфігурації


На момент виходу продукту ІоТ-пристрій має лише два режими: статичний колір та два кольори з інтервалом плавної зміни із сталим знаходженням одного кольору протягом половини часу інтервалу.


4.4.5	Визначення нової конфігурації пристрою серверу пристрою


Щоб визначити нову конфігурацію, достатньо повторити такі ж кроки для реєстрації, старий порт запишеться на новий, а основний сервер отримає останні дані. Менеджеру ІоТ-пристроями залишається тільки видалити старий пристрій через веб-застосунок.


4.5	Мобільний додаток


Мобільний додаток був написаний з використання мови програмування Kotlin за допомогою Jetpack Compose у середовищі Android Studio.
Додаток містить наступну структуру пакетів:
-	models – містить моделі, сервіси, переліки, класи даних (data class);
-	view – містить компоненти Composable, навігації та теми (паект аз замовчуванням);
-	view.models – містить класи, похідні від «ViewModel».
З наведених основних кореневих пакетів можна зробити висновок, що система має архітектуру MVVM: моделі забезпечують дані, перегляди забезпечують їх відображення, а моделі перегляду (ViewModels) запезпечують бізнес-логіку між цими двома шарами.
Для візуалізації використаних пакетів було розроблено діаграму пакетів 
(див. рис. 4.18).

 
Рисунок 4.18. Діаграма пакетів мобільного додатку


4.5.1	Логін та реєстрація


Без авторизації користувач не може продовжити роботу у додатку. Для цього треба увійти у свій акаунт через сторінку логіну (див. рис. 4.19). Якщо ж акаунту немає, його можна створити на сторінці реєстрації (див. рис. 4.20).
При певних помилках буде висвічувати помилку на екрані (див. рис. 4.21).
Для зручності, дані з полів логіну та пароля переносяться між формами, для випадків, коли користувач не одразу розуміє, що треба зареєструватись.
 
Рисунок 4.19. Форма логіну.

 
Рисунок 4.20. Форма реєстрації

 
Рисунок 4.21. Повідомлення про невірні дані: невірний пароль


4.5.2	Літератури


При вдалому вході у додаток, користувач може обрати дві категорії літератур: всі та доступні для читання. Вони відрізняються відповідною фільтрацією других на основі активної сесії бронювання, та кнопкою, що відповідає за читання (див рис. 4.22 та 4.23). Також впроваджено пошук і фільтрацію (див. рис. 4.23). Сторінка деталей відображає всі деталі літератури, і завантажує обкладинку найвищої доступної якості (див. рис. 4.24). При читанні літератури користувачеві доступна лише сама література (див. рис. 4.25), додаткових дій не потрібно для синхронізацію з пристроями в кімнаті, це робиться на стороні бізнес-логіки.
 
Рисунок 4.22. Список всіх літератур.
 
Рисунок 4.23. Література, що можна прочитати, відфільтрована за пошуком та жанрами.


 
Рисунок 4.24. Детальна інформація про літературу

 
Рисунок 4.25. Читання літератури

ВИСНОВКИ


У результаті виконаної роботи була створена програмна система для автоматизації управління освітленням з можливістю адаптації до вмісту електронних книг.
В процесі розробки було проведено аналіз предметної області, спроектовано структуру бази даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи, а також реалізовано ці компоненти за допомогою технологій Python, Flask, React, Kotlin та MySQL.
Розроблена програмна система дозволяє користувачам отримати новий досвід читання електронних книг завдяки адаптивному освітленню, яке налаштовується відповідно до вмісту книги. Користувачі можуть переглядати список доступних книг, фільтрувати їх за різними критеріями, читати книги в мобільному застосунку та автоматично налаштовувати освітлення для комфортного читання.
Система також надає можливість бронювання кімнат у закладах, що використовують цю технологію, та керування налаштуваннями освітлення для персоналу. Персонал може додавати нові книги, редагувати інформацію про них, налаштовувати конфігурацію освітлення для різних сторінок, керувати бронюваннями та IoT-пристроями.
Інтелектуальна система управління освітленням реалізована за допомогою симуляції IoT-пристроїв, які отримують команди на налаштування освітлення з мобільного застосунку користувача.
Згідно з наданими методичними вказівками, у результаті розробки програмної системи була створена детальна пояснювальна записка, яка всебічно описує створену систему, включаючи її функціональні можливості, структурну організацію, архітектурні рішення, етапи проектування, а також технології та методи, що були використані в процесі розробки.
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Welcome to Flask — Flask Documentation (3.0.x). URL: https://flask.palletsprojects.com/en/3.0.x/.
2.	PyCharm: the Python IDE for data science and web development. URL: https://www.jetbrains.com/pycharm/.
3.	Flask-Login 0.7.0 documentation. URL: https://flask-login.readthedocs.io/en/latest/.
4.	marshmallow: simplified object serialization. URL: https://marshmallow.readthedocs.io/en/stable/.
5.	SQLAlchemy - The Database Toolkit for Python. URL: https://www.sqlalchemy.org/.
6.	MySQL. URL: https://www.mysql.com/.
7.	Basic access authentication in the context of an HTTP transaction. URL: https://en.wikipedia.org/wiki/Basic_access_authentication.
8.	Create, read, update and delete. URL: https://en.wikipedia.org/wiki/Create,_read,_update_and_delete.
9.	What is a REST API? URL: https://www.redhat.com/en/topics/api/what-is-a-rest-api.
10.	Chain of Responsibility (Handler). URL: https://refactoring.guru/design-patterns/chain-of-responsibility.
11.	Feature-Sliced Design. https://feature-sliced.design/.
ДОДАТОК А
Діаграми

А.1 UML діаграма прецедентів
 
А.2 ER-діаграма
 

А.3 Діаграма розгортання
 

ДОДАТОК Б
Код серверної частини

Б.1 Серіалізація
0 from __future__ import annotations
1 
2 from abc import ABC, abstractmethod
3 from concurrent.futures import ThreadPoolExecutor, as_completed, Future
4 from dataclasses import dataclass, field
5 from enum import IntEnum, auto
6 from typing import Callable, cast
7 
8 import sqlalchemy.engine.row
9 from icecream import ic
10 from sqlalchemy import Column
11 from sqlalchemy.orm import Session, object_session
12 
13 from app.database.models import Base, User, Country
14 from app.utils.extra import AlchemyExtras, ExtraValidatorsStorageBase
15 
16 
17 class FilterOptions[T]:
18     def __init__(self, predicate: Callable[[T], bool]):
19         self.predicate: Callable[[T], bool] = predicate
20 
21     def list(self, items: list[T]) -> list[T]:
22         return [item for item in items if self.predicate(item)]
23 
24     def dict_keys(self, items: dict[T, any]) -> dict[T, any]:
25         return {key: value for key, value in items.items() if self.predicate(key)}
26 
27     def dict_values(self, items: dict[any, T]) -> dict[any, T]:
28         return {key: value for key, value in items.items() if self.predicate(value)}
29 
30 
31 class DataComparator[T](ABC):
32     def __init__(self):
33         self._options = FilterOptions[T](self.predicate)
34 
35     @abstractmethod
36     def predicate(self, item: T) -> bool:
37         raise NotImplementedError()
38 
39     @property
40     def reflect_on(self) -> FilterOptions[T]:
41         return self._options
42 
43 
44 class SerializationColumnsModifierBase(DataComparator[Column], ABC):
45     def __init__(self, is_exclude_mode: bool):
46         super().__init__()
47         self.columns: set[Column] = set()
48         self.is_exclude_mode: bool = is_exclude_mode
49 
50     def predicate(self, item: Column) -> bool:
51         return self._is_item_excluded(item) if self.is_exclude_mode else self._is_item_included(item)
52 
53     @abstractmethod
54     def _is_item_included(self, item: Column) -> bool:
55         raise NotImplementedError()
56 
57     @abstractmethod
58     def _is_item_excluded(self, item: Column) -> bool:
59         raise NotImplementedError()
60 
61 
62 class DummySerializationColumnsModifier(SerializationColumnsModifierBase):
63 
64     def _is_item_included(self, item: Column) -> bool:
65         return True
66 
67     def _is_item_excluded(self, item: Column) -> bool:
68         return True
69 
70 
71 class SerializationColumnsModifier(SerializationColumnsModifierBase):
72 
73     def _is_item_included(self, item: Column) -> bool:
74         return item in self.columns
75 
76     def _is_item_excluded(self, item: Column) -> bool:
77         return item not in self.columns
78 
79 
80 class ModifiersBundle(DataComparator[Column]):
81     def predicate(self, item: Column) -> bool:
82         return self.included.predicate(item) and self.excluded.predicate(item)
83 
84     def __init__(self, included: SerializationColumnsModifierBase, excluded: SerializationColumnsModifierBase):
85         super().__init__()
86         self.included = included
87         self.excluded = excluded
88 
89 
90 class SerializationModifiersBuilder:
91     def __init__(self):
92         self.included: SerializationColumnsModifierBase = SerializationColumnsModifier(False)
93         self.excluded: SerializationColumnsModifierBase = SerializationColumnsModifier(True)
94 
95     def include_columns(self, *columns: Column):
96         for column in columns:
97             self.included.columns.add(column)
98         return self
99 
100     def exclude_columns(self, *columns: Column):
101         for column in columns:
102             self.excluded.columns.add(column)
103         return self
104 
105     def include_tables(self, *tables: type[Base]):
106         for table in tables:
107             for column in AlchemyExtras().get_columns_of(table).values():
108                 self.included.columns.add(column)
109         return self
110 
111     def exclude_tables(self, *tables: type[Base]):
112         for table in tables:
113             for column in AlchemyExtras().get_columns_of(table).values():
114                 self.excluded.columns.add(column)
115         return self
116 
117     def build(self):
118         return ModifiersBundle(self.included, self.excluded)
119 
120 
121 class SerializationThreadingMode(IntEnum):
122     DISABLED = auto()
123     FULL = auto()
124     PARTIAL = auto()
125 
126 
127 @dataclass
128 class SerializerOptions:
129     threading_mode: SerializationThreadingMode = SerializationThreadingMode.PARTIAL
130     threading_partial_threshold: int = 2000
131 
132 
133 class ModelObjectSerializationResultBuilder:
134 
135     @classmethod
136     def empty(cls):
137         return cls.Result()
138 
139     def __init__(
140             self, obj: Base,
141             recursive_layer_handler_builder: Callable[
142                 [Base | list[Base], list[tuple[Column, Column]]], LayerHandlerBase]
143     ):
144         self.obj = obj
145         self.recursive_layer_handler_builder = recursive_layer_handler_builder
146         self._result = self.empty()
147         self._cols_to_serialize = AlchemyExtras().get_columns_of(obj.__class__)
148         self._relationships_to_serialize = {
149             relationship: AlchemyExtras().get_relationship_parent_and_child_pairs(relationship) for relationship in
150             AlchemyExtras().get_relationships_of(obj.__class__)
151         }
152         self._later_excluded_pairs: list[tuple[Column, Column]] = []
153 
154     @dataclass
155     class Result:
156         dict_data: dict[str, any] = field(default_factory=dict)
157         sync_calls: list[Callable[[], None]] = field(default_factory=list)
158 
159     def apply_columns_filter(self, filter_: Callable[[dict[str, Column]], dict[str, Column]]):
160         self._cols_to_serialize = filter_(self._cols_to_serialize)
161         return self
162 
163     def apply_relationships_filter(self, excluded_pairs: list[tuple[Column, Column]]):
164         self._later_excluded_pairs += excluded_pairs
165         self._relationships_to_serialize = {
166             rel: [tuple([parent, child])
167                   for parent, child in pairs if
168                   [self._ident(parent), self._ident(child)] not in [[self._ident(e_parent), self._ident(e_child)] for
169                                                                     e_parent,
170                                                                     e_child in
171                                                                     excluded_pairs]]
172             for rel, pairs in self._relationships_to_serialize.items()
173         }
174         return self
175 
176     def _ident(self, col: Column):
177         return f'{col.table.name}.{col.key}'
178 
179     def build_result(self):
180         self._result_builder()
181         return self._result
182 
183     def _result_builder(self):
184         if not self._cols_to_serialize:
185             return
186         self._apply_columns_data()
187         self._apply_relations_data()
188 
189     def _apply_columns_data(self):
190         for column in self._cols_to_serialize.values():
191             self._result.dict_data[column.key] = getattr(self.obj, column.key)
192 
193     def _create_sync_call(self, key: str, pairs_to_exclude: list[tuple[Column, Column]]):
194         adjusted_excluded_pairs = self._later_excluded_pairs + [*pairs_to_exclude, *[pair[::-1]
195                                                                                      for pair in pairs_to_exclude]]
196         fill_on_key = key
197 
198         def call():
199             data = getattr(self.obj, fill_on_key)
200             next_layer_handler = self.recursive_layer_handler_builder(data, adjusted_excluded_pairs)
201             inner_data = next_layer_handler.handle_data()
202             if type(inner_data) is dict and not inner_data:
203                 return
204             self._result.dict_data[fill_on_key] = inner_data
205 
206         return call
207 
208     def _apply_relations_data(
209             self,
210     ):
211         for relationship, pairs in self._relationships_to_serialize.items():
212             for parent, child in pairs:
213                 if parent.key in self._cols_to_serialize or child.key in self._cols_to_serialize:
214                     self._result.sync_calls.append(self._create_sync_call(relationship.key, pairs))
215 
216 
217 class LayerHandlerBase(ABC):
218     def __init__(
219             self,
220             object_one_or_many: Base | list[Base],
221             excluded_relation_pairs: list[tuple[Column, Column]],
222             columns_filter: Callable[[dict[str, Column]], dict[str, Column]],
223             next_layer_handler_retriever: Callable[[], type[LayerHandlerBase]],
224             requestor: User | None,
225             extra_validation_data_storage: type[ExtraValidatorsStorageBase],
226             session: Session,
227             result_builder: type[ModelObjectSerializationResultBuilder] = ModelObjectSerializationResultBuilder,
228     ):
229         self.object_one_or_many = object_one_or_many
230         self.excluded_relation_pairs = excluded_relation_pairs
231         self.columns_filter = columns_filter
232         self.requestor = requestor
233         self.next_layer_handler_retriever = next_layer_handler_retriever
234         self.extra_validation_data_storage = extra_validation_data_storage
235         self.session = session
236         self.result_builder = result_builder
237 
238     def handle_data(self):
239         if isinstance(many := self.object_one_or_many, list):
240             if self._is_empty() or not self._is_level_access_allowed(many[0]):
241                 return []
242             return self._handle_many(self._filter_many_with_validation(many))
243         elif isinstance(single := self.object_one_or_many, Base):
244             if not self._is_level_access_allowed(single) or not self._is_item_allowed(single):
245                 return {}
246             return self._handle_single(single)
247 
248     @abstractmethod
249     def _handle_many(self, objs: list[Base]) -> list[dict[str, any]]:
250         pass
251 
252     def _filter_many_with_validation(self, objs: list[Base]) -> list[Base]:
253         return [obj for obj in objs if self._is_item_allowed(obj)]
254 
255     def _handle_single(self, obj: Base) -> dict[str, any]:
256         return self._result_sync_only_finalizer(self._serialize(obj))
257 
258     @staticmethod
259     def _result_sync_only_finalizer(result: ModelObjectSerializationResultBuilder.Result) -> dict[str, any]:
260         [call() for call in result.sync_calls]
261         return result.dict_data
262 
263     @staticmethod
264     def _check_continuum_allowed(result: ModelObjectSerializationResultBuilder.Result):
265         return not not result.dict_data
266 
267     def _is_empty(self):
268         return isinstance(self.object_one_or_many, list) and not self.object_one_or_many
269 
270     def _is_level_access_allowed(self, item: Base):
271         if not (storage := self.extra_validation_data_storage):
272             return True
273 
274         validators_storage = storage()[item.__class__]
275         if not self.requestor:
276             return not validators_storage.validate_NoUser()
277         else:
278             return not validators_storage.validate_User(self.requestor, self.session)
279 
280     def _is_item_allowed(self, item: Base):
281         if not (storage := self.extra_validation_data_storage):
282             return True
283 
284         validators_storage = storage()[item.__class__]
285         if not self.requestor:
286             return not validators_storage.validate_DataWithoutUser(item, None, self.session)
287         else:
288             return not validators_storage.validate_DataWithUser(self.requestor, item, None, self.session)
289 
290 
291     def _create_next_layer_handler(
292             self,
293             object_one_or_many: Base | list[Base],
294             adjusted_excluded_pairs: list[tuple[Column, Column]]
295     ):
296         return self.next_layer_handler_retriever()(
297             columns_filter=self.columns_filter,
298             excluded_relation_pairs=adjusted_excluded_pairs,
299             object_one_or_many=object_one_or_many,
300             requestor=self.requestor,
301             extra_validation_data_storage=self.extra_validation_data_storage,
302             session=self.session,
303             result_builder=self.result_builder,
304             next_layer_handler_retriever=self.next_layer_handler_retriever
305         )
306 
307     def _serialize(
308             self, obj: Base
309     ):
310         return (self.result_builder(obj, self._create_next_layer_handler)
311                 .apply_columns_filter(self.columns_filter)
312                 .apply_relationships_filter(self.excluded_relation_pairs)
313                 .build_result()) if not isinstance(obj, sqlalchemy.engine.row.Row)             else (self.result_builder.Result(dict(obj._mapping), []))
314 
315 
316 class SyncedLayerHandler(LayerHandlerBase):
317     def _handle_many(self, objs: list[Base]) -> list[dict[str, any]]:
318         def inner():
319             for obj in objs:
320                 if not self._check_continuum_allowed(raw_result := self._serialize(obj)):
321                     break
322                 if result := self._result_sync_only_finalizer(raw_result):
323                     yield result
324 
325         return list(inner())
326 
327 
328 class ThreadedLayerHandler(LayerHandlerBase):
329     def _handle_many(self, objs: list[Base]) -> list[dict[str, any]]:
330         def inner():
331             with ThreadPoolExecutor(max_workers=6) as executor:
332                 futures: list[Future] = [executor.submit(self._serialize, obj) for obj in objs if
333                                          self._is_item_allowed(obj)]
334                 for future in as_completed(futures):
335                     if not self._check_continuum_allowed(future.result()):
336                         [f.cancel() for f in futures if not f.done()]
337                         break
338                     yield self._result_sync_only_finalizer(future.result())
339 
340         return list(inner())
341 
342 
343 class RemasteredSerializer:
344     def __init__(
345             self,
346             initial_object: Base | list[Base],
347             requestor: User,
348             session: Session,
349             modifiers: ModifiersBundle = None,
350             options: SerializerOptions = None,
351             extra_validation_data_storage: type[ExtraValidatorsStorageBase] = None,
352     ):
353         self.initial_object = initial_object
354         self.requestor = requestor
355         self.modifiers = modifiers or ModifiersBundle(
356             included=DummySerializationColumnsModifier(False),
357             excluded=DummySerializationColumnsModifier(True),
358         )
359         self.options = options or SerializerOptions()
360         self.extra_validation_data_storage = extra_validation_data_storage
361         self.session = session
362 
363     def _use_threading(self):
364         if self.options.threading_mode == SerializationThreadingMode.DISABLED:
365             return False
366         if self.options.threading_mode == SerializationThreadingMode.FULL:
367             return True
368         if self.options.threading_mode == SerializationThreadingMode.PARTIAL:
369             return isinstance(self.initial_object, list) and (len(self.initial_object) >
370                                                               self.options.threading_partial_threshold)
371 
372     def _layer_handler_retriever(self) -> type[LayerHandlerBase]:
373         return ThreadedLayerHandler if self._use_threading() else SyncedLayerHandler
374 
375     def serialize(self):
376         return (retriever := self._layer_handler_retriever)()(
377             object_one_or_many=self.initial_object,
378             excluded_relation_pairs=[],
379             columns_filter=self.modifiers.reflect_on.dict_values,
380             # columns_filter=lambda x: x,
381             next_layer_handler_retriever=retriever,
382             requestor=self.requestor,
383             extra_validation_data_storage=self.extra_validation_data_storage,
384             session=self.session
385         ).handle_data()
386 
387 
388 class RemasteredSerializerBuilder:
389     def __init__(self):
390         self.init_data = {}
391 
392     def apply_initial_data(self, initial_object: Base | list[Base]):
393         self.init_data.update({'initial_object': initial_object})
394         return self
395 
396     def apply_modifiers(
397             self,
398             modifier_actions: Callable[
399                 [SerializationModifiersBuilder], ModifiersBundle]
400     ):
401         self.init_data.update({'modifiers': modifier_actions(SerializationModifiersBuilder())})
402         return self
403 
404     def define_requestor(self, requestor: User):
405         self.init_data.update({'requestor': requestor})
406         return self
407 
408     def apply_options(self, options: SerializerOptions):
409         self.init_data.update({'options': options})
410         return self
411 
412     def apply_extra_validation_data_storage(
413             self,
414             extra_validation_data_storage: type[ExtraValidatorsStorageBase] | None
415     ):
416         self.init_data.update({'extra_validation_data_storage': extra_validation_data_storage})
417         return self
418 
419     def apply_session(self, session: Session):
420         self.init_data.update({'session': session})
421         return self
422 
423     def build(self):
424         return RemasteredSerializer(**self.init_data)





Б.2 Фільтрація
0 from __future__ import annotations
1 
2 import re
3 from collections import UserList, defaultdict
4 from dataclasses import dataclass
5 from enum import Enum
6 from typing import Callable, cast
7 
8 from flask import Request
9 from icecream import ic
10 from sqlalchemy import Column
11 from sqlalchemy.orm import Query
12 
13 from app.database.models import Base, Literature
14 from app.utils.extra import merge_chained, AlchemyExtras
15 from app.utils.requests.validation.crud import DataTypesAdapter
16 
17 
18 class RequestQuerySupportedArgs(Enum):
19     FILTER = ['filter', 'f', 'fltr', 'filt', 'ftr', 'flt']
20     OFFSET = ['offset', 'shift', 'o', 'start', 'from', 'skip', 'of', 'off', 'ofst']
21     MAX_COUNT = ['max_count', 'max', 'mc', 'limit', 'count', 'pagesize']
22     JOIN = ['join', 'j', 'jn', 'jo', 'jn', 'joi', 'joine', 'joiner']
23 
24     @classmethod
25     def by_tag(cls, tag: str):
26         for enum in cls:
27             if tag.lower() in [v.lower() for v in enum.value]:
28                 return enum
29         return None
30 
31 
32 _args_supported = RequestQuerySupportedArgs
33 
34 
35 class RequestQueryArgsModifiersStorage:
36     _ORDER = [_args_supported.JOIN, _args_supported.FILTER, _args_supported.OFFSET, _args_supported.MAX_COUNT]
37 
38     def __init__(self):
39         self._modifiers_data: dict[_args_supported, list[Callable[[Query], Query]]]             = {e: [] for e in _args_supported}
40 
41     def __iter__(self):
42         return iter(self[arg] for arg in self._ORDER)
43 
44     def __getitem__(self, item: _args_supported):
45         storage = self._modifiers_data[item]
46 
47         class ModifiersUtils(UserList[Callable[[Query], Query]]):
48             def __init__(self):
49                 super().__init__(storage)
50                 self.data: list[Callable[[Query], Query]] = storage
51 
52             def append_first(self, f: Callable[[Query], Query]):
53                 self.insert(0, f)
54 
55             def merged(self) -> Callable[[Query], Query]:
56                 return merge_chained(*self.data)
57 
58             def merge(self):
59                 self.data[:] = [self.merged()]
60 
61             def __call__(self, data: Query):
62                 return self.merged()(data)
63 
64         return ModifiersUtils()
65 
66     def composed(self) -> Callable[[Query], Query]:
67         all_merged = [util.merged() for util in self]
68         return merge_chained(*all_merged)
69 
70 
71 class RequestQueryArgsResolver:
72 
73     def __init__(self, request: Request, for_type: type[Base]):
74         self.all_args = request.args
75         self.base_type = for_type
76         ic(request.url)
77         self.modifiers_storage = RequestQueryArgsModifiersStorage()
78         self._filtered: list[tuple[_args_supported, str]] | None = None
79 
80     def process_args(self):
81         self._filter_args()
82         self._tags_resolve()
83         return self.modifiers_storage.composed()
84 
85     def _filter_args(self):
86         self._filtered = {t: [value for value in values if value]
87                           for key in self.all_args
88                           if (t := _args_supported.by_tag(key.lower()))
89                           and
90                           (values := self.all_args.getlist(key))
91                           }
92 
93     def _tags_resolve(self):
94         if self._filtered is None:
95             raise ValueError('Args was not filtered')
96 
97         for tag, tags_data in self._filtered.items():
98             if tag == _args_supported.JOIN:
99                 self.modifiers_storage[tag].extend(
100                     self._resolve_join_tags_data(tags_data)
101                 )
102             elif tag == _args_supported.FILTER:
103                 self.modifiers_storage[tag].extend(
104                     self._resolve_filtering_tags_data(tags_data)
105                 )
106             elif tag == _args_supported.OFFSET:
107                 self.modifiers_storage[tag].append(
108                     self._offset_to_offset_modifier(self._resolve_offset_tags_data(tags_data))
109                 )
110             elif tag == _args_supported.MAX_COUNT:
111                 self.modifiers_storage[tag].append(
112                     self._max_count_to_max_count_modifier(self._resolve_max_count_tags_data(tags_data))
113                 )
114 
115     @classmethod
116     def _offset_to_offset_modifier(cls, offset: int) -> Callable[[Query], Query]:
117         return lambda query: query.offset(offset)
118 
119     @classmethod
120     def _max_count_to_max_count_modifier(cls, max_count: int) -> Callable[[Query], Query]:
121         return lambda query: cast(Query, query).limit(str(max_count))
122 
123     def _resolve_join_tags_data(self, tags_data: list[str]):
124         def inner():
125             for tag_data in tags_data:
126                 table = self._table_data_to_table(tag_data)
127                 yield self._table_to_join_modifier(table)
128 
129         return list(inner())
130 
131     @classmethod
132     def _table_to_join_modifier(cls, table: type[Base]) -> Callable[[Query], Query]:
133         def modifier(query: Query):
134             return query.join(table)
135 
136         return modifier
137 
138     def _resolve_filtering_tags_data(self, tags_data: list[str]):
139         def inner():
140             in_data: dict[type[Base], dict[Column, list[any]]]                 = defaultdict(lambda: defaultdict(lambda: list()))
141             for tag_data in tags_data:
142                 raw_filtering_data = self._tag_data_to_filtering_data_raw(tag_data)
143                 filtering_data = self._filtering_data_raw_to_filtering_data(raw_filtering_data)
144                 # if filtering_data.operator == "<<":
145                 #     in_data[filtering_data.table][filtering_data.column]+=[filtering_data.value]
146                 # else:
147                 yield self._filtering_data_to_filtering_modifier(filtering_data)
148             # yield self._in_data_to_in_modifier(in_data)
149 
150         return list(inner())
151 
152     def _in_data_to_in_modifier(self, in_data: dict[type[Base], dict[Column, list[any]]]):
153         def modifier(query: Query):
154             for table in in_data:
155                 for column in in_data[table]:
156                     query = query.where(column.in_(in_data[table][column]))
157             return query
158 
159         return modifier
160 
161     _FILTERING_REGEX = r"^[\d\s\W]*(?:(\w+?)[\s\W]*[.])?[\d\s\W]*(\w+?)[\s\W]*?([=><~!]+)(.*)$"
162 
163     @classmethod
164     def _tag_data_to_filtering_data_raw(cls, tag_data: str):
165         match = re.match(cls._FILTERING_REGEX, tag_data)
166         if not match:
167             raise ValueError(f'Invalid filtering tag data: {tag_data}')
168 
169         table, column, operator, value = match.groups()
170         ic(table, column, operator, value)
171 
172         if column is None or operator is None or value is None:
173             raise ValueError(f'Invalid filtering tag data: {tag_data}')
174 
175         return cls.FilteringDataRaw(table, column, operator, value)
176 
177     def _filtering_data_raw_to_filtering_data(self, data_raw: FilteringDataRaw) -> FilteringData:
178         return self.FilteringData(
179             table=(table_base := self._table_data_to_table(data_raw.table)),
180             column=(column := self._column_data_to_column(table_base, data_raw.column)),
181             operator=data_raw.operator,
182             value=self._value_data_to_column_value(table_base, column, data_raw.value)
183         )
184 
185     @classmethod
186     def _filtering_data_to_filtering_modifier(cls, filtering_data: FilteringData):
187         def modifier(query: Query):
188             if filtering_data.operator == '=':
189                 return query.where(filtering_data.column == filtering_data.value)
190             if filtering_data.operator == '!=':
191                 return query.where(filtering_data.column != filtering_data.value)
192             if filtering_data.operator == '>':
193                 return query.where(filtering_data.column > filtering_data.value)
194             if filtering_data.operator == '>=':
195                 return query.where(filtering_data.column >= filtering_data.value)
196             if filtering_data.operator == '<':
197                 return query.where(filtering_data.column < filtering_data.value)
198             if filtering_data.operator == '<=':
199                 return query.where(filtering_data.column <= filtering_data.value)
200             if filtering_data.operator == '~':
201                 return query.where(filtering_data.column.like(f"%{filtering_data.value}%"))
202             raise ValueError(f'Unknown operator: {filtering_data.operator}')
203 
204         return modifier
205 
206     def _table_data_to_table(self, table_data: str | None):
207         if not table_data:
208             return self.base_type
209         return AlchemyExtras().get_table_by_name(table_data)
210 
211     @classmethod
212     def _column_data_to_column(cls, table_base: type[Base], column_data: str):
213         return AlchemyExtras().get_columns_of(table_base)[column_data]
214 
215     @classmethod
216     def _value_data_to_column_value(cls, table_base: type[Base], column: Column, value: str):
217         adapter = DataTypesAdapter(table_base)
218         return adapter.adapt_types({column.key: value})[column.key]
219 
220     @dataclass
221     class FilteringDataRaw:
222         table: str
223         column: str
224         operator: str
225         value: str
226 
227     @dataclass
228     class FilteringData:
229         table: type[Base]
230         column: Column
231         operator: str
232         value: any
233 
234     @classmethod
235     def _resolve_offset_tags_data(cls, tags_data: list[str]):
236         return cls._tags_data_to_int(tags_data)
237 
238     @classmethod
239     def _resolve_max_count_tags_data(cls, tags_data: list[str]):
240         return cls._tags_data_to_int(tags_data)
241 
242     @classmethod
243     def _tags_data_to_int(cls, tags_data: list[str]):
244         one_tag_data = cls._take_one_tag_data(tags_data)
245         return cls._cast_tag_data_to_int(one_tag_data)
246 
247     @classmethod
248     def _take_one_tag_data(cls, tags: list[str], take_last=False):
249         tag = tags[-1 if take_last else 0]
250         return tag
251 
252     @classmethod
253     def _cast_tag_data_to_int(cls, tag: str):
254         return int(tag)
255 


Б.3 Валідація
0 import datetime
1 from dataclasses import dataclass
2 from http import HTTPStatus
3 
4 from flask import Request
5 from flask_sqlalchemy.session import Session
6 from werkzeug.exceptions import BadRequest, UnsupportedMediaType
7 
8 from app import Globals
9 from app.database.models import Base, User
10 from app.utils.extra import AlchemyExtras
11 from app.utils.requests.validation.base import ValidationExceptionType, BasicPhoneNumberLengthValidator, BasicEmailValidator,     BaseDataConverter, ValidationException, BaseValidator, BaseSessionAffectedValidator
12 
13 
14 class RequestJsonTypeValidator(BaseValidator[Request, dict]):
15     def _validation_body(self, context: Request) -> dict:
16         try:
17             return context.get_json()
18         except BadRequest as e:
19             raise ValidationException(ValidationExceptionType.INVALID_JSON, HTTPStatus.BAD_REQUEST, str(e))
20         except UnsupportedMediaType as e:
21             raise ValidationException(ValidationExceptionType.INVALID_JSON, HTTPStatus.UNSUPPORTED_MEDIA_TYPE, str(e))
22 
23 
24 class DummyDataConverter(BaseDataConverter):
25     def convert(self) -> dict[str, any]:
26         return self.unconverted
27 
28     def get_conversion_fields_mapping(self) -> dict[str, str]:
29         return {}
30 
31 
32 class UserDataConverter(BaseDataConverter):
33     def convert(self):
34         converted = {}
35         for key, value in self.unconverted.items():
36             if key == "password":
37                 converted["password_hash"] = Globals().bcrypt.generate_password_hash(value).decode("utf-8")
38             elif key == "phone_number":
39                 BasicPhoneNumberLengthValidator().validate(value)
40                 converted["phone_number"] = value
41             elif key == "email":
42                 BasicEmailValidator().validate(value)
43                 converted["email"] = value
44             else:
45                 converted[key] = value
46         return converted
47 
48     def get_conversion_fields_mapping(self) -> dict[str, str]:
49         return {"password": "password_hash"}
50 
51 
52 class DataTypesAdapter:
53     def __init__(self, model: type[Base]):
54         self.model = model
55 
56     def adapt_types(self, data: dict[str, any]) -> dict[str, any]:
57         all_columns = AlchemyExtras().get_columns_of(self.model)
58         for column_name, column in all_columns.items():
59             if column_name in data.keys():
60                 if column.type.python_type == datetime.datetime:
61                     continue
62                 elif data[column_name] is None and column.nullable:
63                     continue
64                 else:
65                     data[column_name] = column.type.python_type(data[column_name])
66         return data
67 
68 
69 class DataConvertersFactory:
70     @staticmethod
71     def get_data_converter(data_type: type[Base]) -> type[BaseDataConverter]:
72         if data_type == User:
73             return UserDataConverter
74         else:
75             return DummyDataConverter
76 
77 
78 @dataclass
79 class ConvertedDataTypesUnmatched:
80     data: dict[str, any]
81     model: type[Base]
82 
83 
84 @dataclass
85 class ConvertedData:
86     data: dict[str, any]
87     model: type[Base]
88 
89 
90 class RawJsonDataConversionValidator(BaseValidator[dict, ConvertedDataTypesUnmatched]):
91     def __init__(self, model: type[Base], *args, **kwargs):
92         super().__init__(*args, **kwargs)
93         self.model = model
94 
95     def _validation_body(self, context: dict) -> ConvertedData:
96         converter = DataConvertersFactory.get_data_converter(self.model)
97         try:
98             return ConvertedData(converter(context).convert(), self.model)
99         except ValidationException as e:
100             raise ValidationException(ValidationExceptionType.RAW_JSON_CONVERSION_EXCEPTION, HTTPStatus.BAD_REQUEST, e)
101 
102 
103 class TypesAdapterValidator(BaseValidator[ConvertedDataTypesUnmatched, ConvertedData]):
104     def _validation_body(self, context: ConvertedDataTypesUnmatched) -> ConvertedData:
105         adapter = DataTypesAdapter(context.model)
106         try:
107             return ConvertedData(adapter.adapt_types(context.data), context.model)
108         except ValueError as e:
109             raise ValidationException(ValidationExceptionType.TYPES_CONVERSION_EXCEPTION, HTTPStatus.BAD_REQUEST, e)
110 
111 
112 class IntegrityRedundantFieldsValidator(BaseValidator[ConvertedData, ConvertedData]):
113     def _validation_body(self, context: ConvertedData) -> ConvertedData:
114         all_columns = AlchemyExtras().get_columns_of(context.model)
115         all_relationships = AlchemyExtras().get_relationships_of(context.model)
116         for key in context.data.keys():
117             if key in all_relationships:
118                 raise ValidationException(
119                     ValidationExceptionType.DIRECT_RELATIONSHIPS_UNSUPPORTED, HTTPStatus.BAD_REQUEST, key
120                 )
121             if key not in all_columns:
122                 raise ValidationException(
123                     ValidationExceptionType.REQUEST_BODY_UNKNOWN_FIELD, HTTPStatus.BAD_REQUEST, key
124                 )
125         return context
126 
127 
128 class IntegrityAllFieldsPresenceValidator(BaseValidator[ConvertedData, ConvertedData]):
129     def __init__(self, force_add_nullables: bool = True, *args, **kwargs):
130         super().__init__(*args, **kwargs)
131         self.force_add_nullables = force_add_nullables
132 
133     def _validation_body(self, context: ConvertedData) -> ConvertedData:
134         all_columns = AlchemyExtras().get_columns_of(context.model)
135         for column_name, column in all_columns.items():
136             if context.data.get(column_name) is None and self.force_add_nullables and column.nullable:
137                 context.data[column_name] = None
138                 continue
139 
140             if column.autoincrement:
141                 continue
142 
143             if column_name not in context.data.keys():
144                 raise ValidationException(
145                     ValidationExceptionType.REQUEST_BODY_MISSING_FIELD, HTTPStatus.BAD_REQUEST, f'{column_name} not found'
146                 )
147         return context
148 
149 
150 class IntegrityPrimaryKeyPresenceValidator(BaseValidator[ConvertedData, ConvertedData]):
151     def _validation_body(self, context: ConvertedData) -> ConvertedData:
152         primary_key = AlchemyExtras().get_pk_of(context.model)
153         for column in primary_key:
154             if column.key not in context.data.keys():
155                 raise ValidationException(
156                     ValidationExceptionType.REQUEST_BODY_MISSING_PK, HTTPStatus.BAD_REQUEST, column
157                 )
158         return context
159 
160 
161 class ExistencePrimaryKeyValidator(BaseSessionAffectedValidator[ConvertedData, tuple[ConvertedData, Base]]):
162     def _validation_body(self, context: ConvertedData) -> tuple[ConvertedData, Base]:
163         primary_key = AlchemyExtras().get_pk_of(context.model)
164         primary_key_data = {column.key: context.data[column.key] for column in primary_key if
165                             column.key in context.data}
166 
167         if (found_object := self.session.get(context.model, primary_key_data)) is None:
168             raise ValidationException(
169                 ValidationExceptionType.PK_OBJECT_NOT_FOUND, HTTPStatus.BAD_REQUEST, f'{primary_key} not found'
170             )
171         return context, found_object
172 
173 
174 class NonExistencePrimaryKeyValidator(BaseSessionAffectedValidator[ConvertedData, ConvertedData]):
175     def __init__(self, session: Session, excluded_pk_from_header: dict[str, any] | None = None, *args, **kwargs):
176         super().__init__(session, *args, **kwargs)
177         self.excluded_pk_from_header = excluded_pk_from_header
178 
179     def _validation_body(self, context: ConvertedData) -> ConvertedData:
180         primary_key = AlchemyExtras().get_pk_of(context.model)
181         primary_key_data = {column.key: context.data[column.key] for column in primary_key if
182                             column.key in context.data}
183         if len(primary_key_data) == 0 or self.excluded_pk_from_header == primary_key_data:
184             return context
185 
186         if len(primary_key_data) != len(primary_key):
187             required = set(column.key for column in primary_key)
188             missing = required-set(primary_key_data.keys())
189             raise ValidationException(
190                 ValidationExceptionType.PK_FIELDS_COUNT_MISMATCH, HTTPStatus.BAD_REQUEST, f'Missing fields {missing} for '
191                                                                                       f'PK {required}'
192             )
193 
194         if self.session.get(context.model, primary_key_data) is not None:
195             raise ValidationException(
196                 ValidationExceptionType.PK_OBJECT_ALREADY_EXISTS, HTTPStatus.BAD_REQUEST, f'{primary_key} already exists'
197             )
198         return context
199 
200 
201 class ExistenceForeignKeysValidator(BaseSessionAffectedValidator[ConvertedData, ConvertedData]):
202     def _validation_body(self, context: ConvertedData) -> ConvertedData:
203         all_relationships = AlchemyExtras().get_relationships_of(context.model)
204         relationships_data = [pair for relationship in all_relationships for pair in
205                               AlchemyExtras().get_relationship_parent_and_child_pairs(relationship)]
206         parents_and_children = {child: parent for parent, child in relationships_data if child.key in context.data}
207         foreign_keys_data = {column: context.data[column.key] for column in parents_and_children}
208         for child, value in foreign_keys_data.items():
209             parent = parents_and_children[child]
210             if self.session.get(AlchemyExtras().get_table_by_name(parent.table.name), {parent.key: value}) is None:
211                 raise ValidationException(
212                     ValidationExceptionType.PARENT_OBJECT_NOT_FOUND, HTTPStatus.BAD_REQUEST, child
213                 )
214         return context
215 
216 
217 class MarshmallowLoadValidator(BaseSessionAffectedValidator[ConvertedData, Base]):
218     def _validation_body(self, context: ConvertedData) -> Base:
219         schema = AlchemyExtras().get_schema_of(context.model)
220         try:
221             return schema(session=self.session).load(context.data)
222         except Exception as e:
223             raise ValidationException(
224                 ValidationExceptionType.MARSHMALLOW_VALIDATION_EXCEPTION, HTTPStatus.BAD_REQUEST, e
225             )
226 
227 
228 @dataclass
229 class CRUDContext:
230     model: type[Base]
231     request: Request
232 
233 
234 @dataclass
235 class CreateValidationResult:
236     object_to_create: Base
237 
238 
239 class CRUDBasicCreateValidator(BaseSessionAffectedValidator[CRUDContext, CreateValidationResult]):
240 
241     def _validation_body(self, context: CRUDContext) -> CreateValidationResult:
242         object_to_create: Base | None = None
243 
244         def on_validation_success(new_object: Base):
245             nonlocal object_to_create
246             object_to_create = new_object
247 
248         body_validators = RequestJsonTypeValidator()
249         body_validators.set_next(RawJsonDataConversionValidator(context.model)).set_next(
250             TypesAdapterValidator()
251             ).set_next(IntegrityRedundantFieldsValidator()).set_next(IntegrityAllFieldsPresenceValidator()).set_next(
252             NonExistencePrimaryKeyValidator(self.session)
253             ).set_next(ExistenceForeignKeysValidator(self.session)).set_next(
254             MarshmallowLoadValidator(self.session, on_validation_success)
255             )
256 
257         try:
258             body_validators.validate(context.request)
259         except ValidationException as e:
260             raise ValidationException(ValidationExceptionType.CREATE_VALIDATION_EXCEPTION, HTTPStatus.BAD_REQUEST, e)
261 
262         assert object_to_create is not None
263 
264         return CreateValidationResult(object_to_create)
265 
266 
267 @dataclass
268 class ReadOrDeleteValidationResult:
269     object: Base
270 
271 
272 class CRUDBasicReadOrDeleteValidator(BaseSessionAffectedValidator[CRUDContext, ReadOrDeleteValidationResult]):
273 
274     def _validation_body(self, context: CRUDContext) -> ReadOrDeleteValidationResult:
275         final_object: Base | None = None
276 
277         def on_validation_success(data: tuple[ConvertedData, Base]):
278             nonlocal final_object
279             final_object = data[1]
280 
281         header_validators = RawJsonDataConversionValidator(context.model)
282         header_validators.set_next(
283             TypesAdapterValidator()
284         ).set_next(
285             IntegrityPrimaryKeyPresenceValidator()
286         ).set_next(
287             ExistencePrimaryKeyValidator(
288                 self.session, on_validation_success
289             )
290         )
291 
292         try:
293             header_validators.validate(context.request.view_args)
294         except ValidationException as e:
295             raise ValidationException(ValidationExceptionType.READ_VALIDATION_EXCEPTION, HTTPStatus.BAD_REQUEST, e)
296 
297         assert final_object is not None
298 
299         return ReadOrDeleteValidationResult(final_object)
300 
301 
302 @dataclass
303 class UpdateValidationResult:
304     object_new_data: dict[str, any]
305     object_to_update: Base
306 
307 
308 class CRUDBasicUpdateValidator(BaseSessionAffectedValidator[CRUDContext, UpdateValidationResult]):
309     def _validation_body(self, context: CRUDContext) -> UpdateValidationResult:
310         data_to_update: dict[str, any] = {}
311         object_to_update: Base | None = None
312 
313         def on_header_validation_success(data: tuple[ConvertedData, Base]):
314             nonlocal object_to_update
315             object_to_update = data[1]
316 
317         def on_body_validation_success(data: ConvertedData):
318             nonlocal data_to_update
319             data_to_update = data.data
320 
321         header_validators = RawJsonDataConversionValidator(context.model)
322         header_validators.set_next(TypesAdapterValidator()).set_next(
323             IntegrityPrimaryKeyPresenceValidator()
324         ).set_next(
325             ExistencePrimaryKeyValidator(self.session, on_header_validation_success)
326         )
327 
328         body_validators = RequestJsonTypeValidator()
329         body_validators_cont = body_validators.set_next(RawJsonDataConversionValidator(context.model)).set_next(
330             TypesAdapterValidator()
331         ).set_next(
332             IntegrityRedundantFieldsValidator()
333         )
334 
335         try:
336             header_validators.validate(context.request.view_args)
337             body_validators_cont.set_next(
338                 NonExistencePrimaryKeyValidator(
339                     self.session, excluded_pk_from_header={col.key: getattr(object_to_update, col.key) for col in
340                         AlchemyExtras().get_pk_of(object_to_update.__class__)}
341                     )
342             ).set_next(
343                 ExistenceForeignKeysValidator(
344                     self.session, on_body_validation_success
345                 )
346             )
347             body_validators.validate(context.request)
348         except ValidationException as e:
349             raise ValidationException(ValidationExceptionType.UPDATE_VALIDATION_EXCEPTION, HTTPStatus.BAD_REQUEST, e)
350 
351         assert object_to_update is not None
352 
353         return UpdateValidationResult(data_to_update, object_to_update)
354
 
